(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{573:function(t,e,s){"use strict";s.r(e);var a=s(12),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"作用域链的定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域链的定义"}},[t._v("#")]),t._v(" 作用域链的定义")]),t._v(" "),s("p",[t._v("当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。")]),t._v(" "),s("h2",{attrs:{id:"作用域链的构建"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域链的构建"}},[t._v("#")]),t._v(" 作用域链的构建")]),t._v(" "),s("p",[t._v("作用域链的构建,其实本质上是函数的内部属性"),s("code",[t._v("[[scope]]")]),t._v(", "),s("code",[t._v("[[[scope]]")]),t._v("当中保存的是父变量对象, 这个 "),s("code",[t._v("[[scope]]")]),t._v("属性最终会被先复制到当前执行上下文对象当中")])])}),[],!1,null,null,null);e.default=r.exports}}]);