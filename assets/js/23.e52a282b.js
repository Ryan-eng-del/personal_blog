(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{570:function(t,s,e){"use strict";e.r(s);var i=e(12),o=Object(i.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("从 ECMA 规范的角度, 实在是有些晦涩, 《你不知道的 js 》这本书当中关于 this 内容我觉得很好的阐述了 this 的规则.")]),t._v(" "),e("h2",{attrs:{id:"this-的四项绑定规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#this-的四项绑定规则"}},[t._v("#")]),t._v(" this 的四项绑定规则")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("默认绑定: 独立函数调用, 可以将这条规则看作是无法引用与其他规则的默认规则.(this 在非严格模式下等于 window, 在严格模式下等于 undefined)")])]),t._v(" "),e("li",[e("p",[t._v("隐式绑定:考虑调用位置是否有上下文对象, 隐式绑定有最常见的 this 绑定问题, this 丢失, 有四种情况, 函数别名"),e("code",[t._v("var bar = obj.foo; bar();")]),t._v(" 传入回调函数, 传入语言内置的函数(setTimeout 函数) 调用回调函数的函数会修改 this(react 当中点击事件显示绑定 this, 就是防止 react 内部调用修改 this)")])]),t._v(" "),e("li",[e("p",[t._v("显示绑定: 通过 apply 和 call 来显示绑定 this, 还有一种显示绑定的变种是硬绑定 bind()")])]),t._v(" "),e("li",[e("p",[t._v("new: 这就要想到 new 一个构造函数发生了什么, 1.创建一个空对象 2.将这个空对象的"),e("code",[t._v("__proto__")]),t._v("指定到构造函数的"),e("code",[t._v("prototype")]),t._v("上, 3.绑定构造函数当中的 this 到这个空对象, 执行构造函数当中的代码 4.构造函数当中是否有返回值 ,没有就返回这个实例对象, 有就看返回的是否是对象类型, 是就返回这个对象, 不是就返回实例对象")])])])])}),[],!1,null,null,null);s.default=o.exports}}]);